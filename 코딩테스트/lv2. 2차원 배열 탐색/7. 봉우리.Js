/**
 * -----------------------------
 *	7. 봉우리
 * -----------------------------
 *  지도 정보가 N*N 격자판에 주어집니다. 각 격자에는 그 지역의 높이가 쓰여있습니다.
 *  각 격자 판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역입니다.
 *  봉우리 지역이 몇 개 있는 지 알아내는 프로그램을 작성하세요.
 *  격자의 가장자리는 0으로 초기화 되었다고 가정한다.
 *  만약 N=5 이고, 격자판의 숫자가 다음과 같다면 봉우리의 개수는 10개입니다.
 *
 * > 봉우리의 개수를 출력하세요.
 *
 * * 입력
    let arr = [
      [5, 3, 7, 2, 3],
      [3, 7, 1, 6, 1],
      [7, 2, 5, 3, 4],
      [4, 3, 6, 4, 1],
      [8, 7, 3, 5, 2],
    ];

 * * 출력 - 10
 */

let arr = [
  [5, 3, 7, 2, 3],
  [3, 7, 1, 6, 1],
  [7, 2, 5, 3, 4],
  [4, 3, 6, 4, 1],
  [8, 7, 3, 5, 2],
];

function solution(arr) {
  let result = 0;
  let length = arr.length;

  // 상하좌우 이동을 위한 방향을 정의한 배열 dX, dY를 선언합니다.
  // dX는 행 이동, dY는 열 이동을 위한 것입니다.
  let dX = [-1, 0, 1, 0];
  let dY = [0, 1, 0, -1];

  // 격자판의 모든 원소를 검사하기 위해 이중 반복문을 사용합니다.
  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length; j++) {
      // 현재 위치가 봉우리인지 확인하는 flag를 설정합니다. (1이면 봉우리)
      let flag = 1;

      // 상하좌우 방향을 검사하기 위한 반복문입니다.
      for (let k = 0; k < 4; k++) {
        // 현재 위치에서 방향에 따라 이동한 새로운 위치를 계산합니다.
        let nX = i + dX[k];
        let nY = j + dY[k];

        // 새로운 위치가 유효하고 (즉, 격자판 범위 안에 있고),
        // 새로운 위치의 원소가 현재 원소보다 크거나 같다면,
        // 현재 위치는 봉우리가 아닙니다.
        if (
          nX >= 0 &&
          nX < length &&
          nY >= 0 &&
          nY < length &&
          arr[nX][nY] >= arr[i][j]
        ) {
          flag = 0; // 봉우리가 아님을 표시
          break; // 더 이상 검사할 필요가 없으므로 이 반복문을 빠져나갑니다.
        }
      }

      // 현재 위치가 봉우리라면 결과값을 증가시킵니다.
      if (flag) result++;
    }
  }

  // 최종 결과값을 반환합니다.
  return result;
}

console.log('solution --->', solution(arr));

/**
 * -----------------------------
 * ! 이 함수는 O(n^2)의 시간 복잡도를 가지며, n은 배열의 길이입니다. 이는 격자판의 모든 원소를 검사해야 하기 때문입니다.
 * -----------------------------
 * nX = i + dX[k]
   = 3 + dX[0]
   = 3 + (-1)
   = 2
 *
 */
